function err = upload_phys_bdata(spkS)
% function err = upload_phys_bdata(res)
% 
% Takes a struct spkS with results from the sorting process. For example,
% generated by get_ksphy results.
% 
% spkS should be a struct array where each entry corresponds to a tetrode
% and has the following fields
%
%   ratname         str 
%   sessid          int key to get relevant behavior session from sessions table
%   eibid           int key into ratinfo.eibids for this recording device
%   trodenum        int tetrode number on this eib indexed from 1
%   recpath         str path to the recording for this tetrode
%   fs              int sampling rate of recording
%   hd              str header of recording - 
%   clusnotespath   str path to a txt file containing notes on each cluster
%   sync_fit_m      1x1 regression slope for converting phys ttls to FSM time  
%   sync_fit_b      1x1 regression intercept for converting phys ttls to FSM time  
%   event_ts_fsm    nspikes x 1 when did the spikes happen in FSM time
%   event_clus      nspikes x 1 cluster id for each spike (indexed from 1)
%   wv_mn           nclusts x ntimepoints x nchannelspertrode mean waveform in uv
%   wv_std 
%   
%   

err = 0;

% make sure this sessid corresponds to the expected rat
assert(length(unique([spkS.sessid]))==1);
sessid  = spkS(1).sessid;
ratname = bdata('select ratname from sessions where sessid="{S}"',sessid);
ratname = ratname{1};
assert(strcmp(ratname,spkS(1).ratname));

% Load cutting notes, and fsm syncing parameters in the phys_sess table
in_phys_sess = bdata('select count(sessid) from phys_sess where sessid="{Si}"',sessid);
if ~in_phys_sess
    clusnotespath   = spkS(1).clusnotespath;
    sync_fit_m      = spkS(1).sync_fit_m;
    sync_fit_b      = spkS(1).sync_fit_b;
    bdata(['insert into phys_sess (sessid, ratname, cutting_notes, '...
        'sync_fit_m, sync_fit_b) values ("{Si}","{S}", "{F}","{S12}","{S12}")'],...
        sessid,ratname,clusnotespath,sync_fit_m,sync_fit_b);
end

% load each tetrode into bdata
for ss = 1:length(spkS)
    sc_num      = spkS(ss).trodenum - 1;
    % check cells table for this tetrode
    is_in_cells = bdata('select count(*) from cells where sessid="{Si}" and sc_num="{Si}"', sessid, sc_num);
    if is_in_cells > 0
        warning('already uploaded cells for this session and channel')
        keyboard
    end
    upload_phys_bdata_(spkS(ss))
end

function upload_phys_bdata_(spkS)
sessid      = spkS.sessid;
trodenum    = spkS.trodenum;
recpath     = spkS.recpath;
fs          = spkS.fs;
sc_num      = trodenum - 1;
chans       = sc_num+(0:3);

% get some information about this recording
[fldr, rec_fn, ext]   = fileparts(recpath);
rec_fn  = [rec_fn ext];
if strcmp(ext,'ntt')
    fid     = fopen(fullfile(recpath),'r');
    hd      = fread(fid,16384);  % The header of all nlx files is 16384 bytes
    hd      = char(hd');   % reformat the header to a human readable format.
    % check that the file name agrees with the tetrode number
    filetrodenum    = str2num(rec_fn( regexp(rec_fn,'\d')));
    assert(trodenum == filetrodenum);
    [wsc, chans_, cheetah_ver] = extract_header(hd);
    if ~isequal(chans_,chans)
        warning('header disagrees about what channels you''re looking at');
        keyboard;
    end
else
    hd = sprintf('recording file name: %s\nsampling rate %i', recpath, fs);
end

% update channels table for this tetrode
in_channels = bdata(['select count(sessid) from bdata.channels where '...
    'sessid="{Si}" and file_name="{S}"'],sessid,rec_fn);
if ~in_channels
    sqlstr=['insert into bdata.channels (sessid, ad_channels, header, file_name, path_name) ' ...
        ' values ("{Si}","{S}","{S}","{S}","{S}")'];
    bdata(sqlstr, sessid, chans, hd, rec_fn, fldr);
    channelid=bdata('select last_insert_id()');
else
    warning('already uploaded channel for this file name')
    keyboard
end




try

    %%  For each cell in the spike file
    
    unique_clusters=unique(clusternum);
    for cc = 1:numel(unique_clusters)
        cl_n = unique_clusters(cc);

        % first the cell table
        nSpikes     = sum(clusternum==cl_n);
        cluster_in_file = cl_n;
        cluster = cc; % need to sc_num+1 because the channels are 0 indexed.
        sqlstr  = ['insert into bdata.cells (ratname, sessid, channelid,' ...
            'sc_num, cluster, nSpikes, filename, cluster_in_file, eibid)' ...
            'values ("{S}","{Si}","{Si}","{Si}","{Si}","{Si}","{S}","{Si}","{Si}")'];
        bdata(sqlstr,ratname,sessid, channelid, sc_num, cluster, nSpikes, rec_fn, cl_n, eibid);
        cellid = bdata('select last_insert_id()');
        % then the spike
        this_clust = clusternum == cl_n;
        c_ts   = ts_fsm_s(this_clust);
        % squeeze breaks for single electrodes
        % 				w.mn=squeeze(mean(waves(cell_n==cl_n,:,:)));
        % permute like this removes a leading singleton dimension
        w.mn    = squeeze(mean(waves(this_clust,:,:)))';
 
        try
            % squeeze breaks for single electrodes
            %     				w.std=squeeze(std(waves(cell_n==cl_n,:,:)));
            % permute like this removes a leading singleton dimension
            w.std = squeeze(std(waves(this_clust,:,:)))';
        catch
            try
                sprintf(['not enough memory to compute std of waveform ...'
                    'recomputing sample std']);
                w.std = std(waves(this_clust.*(rand(size(this_clust))<.5),:,:))';
            catch
                sprintf('failed')
            end
        end;
        % insert cluster into spiketimes
        sqlstr = ['insert into bdata.spktimes (cellid, sessid, ts, wave) '...
            'values ("{Si}","{Si}","{M}","{M}")'];
        bdata(sqlstr, cellid, sessid, c_ts, w);
        
        
    end
catch
    showerror(lasterror);
end


err = 0;








